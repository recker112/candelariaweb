{"version":3,"sources":["../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../../../node_modules/react-hook-form/dist/index.esm.js","../../../node_modules/@material-ui/core/esm/InputAdornment/InputAdornment.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"],"names":["_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","unsupportedIterableToArray","i","F","s","n","length","done","value","e","_e","f","TypeError","it","err","normalCompletion","didErr","step","next","_e2","isHTMLElement","HTMLElement","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","attachEventListeners","shouldAttachChangeEvent","handleChange","ref","addEventListener","isNullOrUndefined","isObjectType","isObject","Date","isKey","test","compact","filter","Boolean","stringToPath","input","replace","split","set","object","path","index","tempPath","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","isUndefined","val","undefined","get","obj","defaultValue","result","reduce","focusOnErrorField","fields","fieldErrors","field","focus","options","removeAllEventListeners","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","getRadioValue","previous","option","checked","isRadioInput","element","type","isFileInput","isCheckBoxInput","isMultipleSelect","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fieldsRef","name","shallowFieldsStateRef","excludeDisabled","current","disabled","files","selected","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","isEmptyObject","Object","keys","isBoolean","unset","updatePath","childObject","slice","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isSameRef","fieldValue","findRemovedFieldAndRemoveListener","shouldUnregister","forceDelete","fieldRef","forEach","setFieldArrayDirtyFields","defaultValues","dirtyFields","parentName","assign","isString","isPrimitive","getFieldsValues","shallowFieldsState","search","output","startsWith","find","deepMerge","target","source","targetValue","sourceValue","_a","deepEqual","object1","object2","isErrorObject","keys1","keys2","includes","val1","val2","isErrorStateChanged","errors","error","validFields","fieldsWithValidation","previousError","isRegex","RegExp","getValueAndMessage","validationData","message","isFunction","isMessage","isValidElement","getValidateError","appendErrors","validateAllFieldCriteria","types","validateField","a","required","maxLength","minLength","min","max","pattern","validate","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","maxOutput","minOutput","valueNumber","valueAsNumber","parseFloat","exceedMin","valueDate","valueAsDate","maxLengthOutput","minLengthOutput","patternValue","validateRef","validateError","validationResult","entries","validateFunction","validateResult","getPath","pathWithIndex","getInnerPath","flat","Infinity","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","getFieldArrayParentName","substring","indexOf","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","isSelectInput","onDomRemove","removeFieldEventListenerAndRef","observer","MutationObserver","observe","window","document","childList","subtree","cloneObject","isWeb","copy","File","getTime","Set","Map","modeChecker","mode","isOnSubmit","isRadioOrCheckboxFunction","isWindowUndefined","isProxyEnabled","Proxy","useForm","reValidateMode","resolver","context","shouldFocusError","criteriaMode","useRef","fieldArrayDefaultValuesRef","fieldArrayValuesRef","watchFieldsRef","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","isValidateAllFieldCriteria","useState","isDirty","submitCount","touched","isSubmitting","isSubmitSuccessful","formState","setFormState","readFormStateRef","formStateRef","observerRef","updateFormState","useCallback","state","shouldRenderBaseOnError","shouldRender","shouldReRender","setFieldValue","rawValue","radioRef","selectRef","checkboxRef","isFormDirty","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","Promise","all","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","isFieldWatched","match","renderWatchedInputs","found","size","setValue","setFieldArrayDefaultValues","payload","shouldSkipValidation","parentNodeName","lastIndexOf","currentError","validateResolver","removeFieldEventListener","updateWatchedValue","clearErrors","inputName","setError","shouldFocus","watchInternal","fieldNames","watchId","combinedDefaultValues","fieldArrayValue","watch","unregister","registerFieldRef","validateOptions","fieldRefAndValidationOptions","isFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","register","refOrValidationOptions","rules","handleSubmit","onValid","onInvalid","preventDefault","persist","fieldError","resetRefs","reset","omitResetState","inputRef","closest","resetFieldArray","useEffect","disconnect","commonProps","control","useMemo","prop","__rest","t","p","prototype","hasOwnProperty","call","getOwnPropertySymbols","propertyIsEnumerable","FormContext","createContext","displayName","useFormContext","useContext","FormProvider","children","props","createElement","Provider","generateId","d","performance","now","c","r","Math","random","toString","useWatch","methods","updateValue","idRef","defaultValueRef","id","watchFieldsHookRender","watchFieldsHook","Controller","as","render","onFocus","rest","isNotFieldArray","getInitialValue","setInputStateValue","valueRef","onFocusRef","commonTask","event","getInputValue","registerField","shouldUpdateValue","defineProperty","onBlur","onChange","cloneElement","InputAdornment","React","classes","className","_props$component","component","Component","_props$disablePointer","disablePointerEvents","_props$disableTypogra","disableTypography","position","variantProp","variant","other","_objectWithoutProperties","muiFormControl","useFormControl","FormControlContext","_extends","clsx","root","hiddenLabel","filled","positionStart","positionEnd","margin","marginDense","Typography","color","withStyles","display","height","maxHeight","alignItems","whiteSpace","marginTop","marginRight","marginLeft","pointerEvents","_toConsumableArray","arr","arrayLikeToArray","iter","from"],"mappings":"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","file":"static/js/2.f4382e5a.chunk.js","sourcesContent":["import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => !Array.isArray(value) &&\r\n    (/^\\w*$/.test(value) ||\r\n        !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar compact = (value) => value.filter(Boolean);\n\nvar stringToPath = (input) => compact(input\r\n    .replace(/[\"|']/g, '')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.'));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data, value = {}) => {\r\n    for (const key in data) {\r\n        !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\r\n    }\r\n    return value;\r\n};\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus && isUndefined(field.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const path = updatePath.slice(0, -1);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef = undefined;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name, type }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\r\n    }\r\n    if (!type) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\r\n        if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\r\n            compact(fieldRef.options).forEach((option, index) => {\r\n                if ((option.ref &&\r\n                    isDetached(option.ref) &&\r\n                    isSameRef(option, option.ref)) ||\r\n                    forceDelete) {\r\n                    removeAllEventListeners(option.ref, handleChange);\r\n                    unset(fieldRef.options, `[${index}]`);\r\n                }\r\n            });\r\n            if (fieldRef.options && !compact(fieldRef.options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nfunction setFieldArrayDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setFieldArrayDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                get(defaultValues[index] || {}, key) === values[index][key]\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        !dirtyFields.length &&\r\n            parentNode &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields.length ? dirtyFields : undefined;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return shouldUnregister\r\n        ? transformToNestObject(output)\r\n        : deepMerge(shallowFieldsState, transformToNestObject(output));\r\n};\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        if (!(isErrorObject && ['ref', 'context'].includes(key))) {\r\n            const val1 = object1[key];\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2, isErrorObject)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction isErrorStateChanged({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox\r\n                    ? ((fieldsRef.current[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            value.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            value.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (key, value, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return Object.entries(values)\r\n        .map(([key, value]) => getInnerPath(key, value, isObject(values)))\r\n        .flat(Infinity);\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nfunction cloneObject(data, isWeb) {\r\n    let copy;\r\n    if (isPrimitive(data) || (isWeb && data instanceof File)) {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n        return copy;\r\n    }\r\n    if (data instanceof Set) {\r\n        copy = new Set();\r\n        for (const item of data) {\r\n            copy.add(item);\r\n        }\r\n        return copy;\r\n    }\r\n    if (data instanceof Map) {\r\n        copy = new Map();\r\n        for (const key of data.keys()) {\r\n            copy.set(key, cloneObject(data.get(key), isWeb));\r\n        }\r\n        return copy;\r\n    }\r\n    copy = Array.isArray(data) ? [] : {};\r\n    for (const key in data) {\r\n        copy[key] = cloneObject(data[key], isWeb);\r\n    }\r\n    return copy;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isWeb = typeof document !== UNDEFINED &&\r\n    !isWindowUndefined &&\r\n    !isUndefined(window.HTMLElement);\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const fieldArrayDefaultValuesRef = useRef({});\r\n    const fieldArrayValuesRef = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const useWatchFieldsRef = useRef({});\r\n    const useWatchRenderFunctionsRef = useRef({});\r\n    const fieldsWithValidationRef = useRef({});\r\n    const validFieldsRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const shallowFieldsStateRef = useRef({});\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const contextRef = useRef(context);\r\n    const resolverRef = useRef(resolver);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const modeRef = useRef(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = useState({\r\n        isDirty: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = useRef(formState);\r\n    const observerRef = useRef();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = useRef(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    shallowFieldsStateRef.current = shouldUnregister\r\n        ? {}\r\n        : isEmptyObject(shallowFieldsStateRef.current)\r\n            ? cloneObject(defaultValues, isWeb)\r\n            : shallowFieldsStateRef.current;\r\n    const updateFormState = useCallback((state = {}) => !isUnMount.current &&\r\n        setFormState(Object.assign(Object.assign({}, formStateRef.current), state)), []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state)) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), { errors: formStateRef.current.errors }), (resolverRef.current ? { isValid: !!isValid } : {})));\r\n        }\r\n    }, []);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = Array.isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = useCallback((name, data) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const formValues = getValues();\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, isEmptyObject(defaultValuesRef.current)\r\n                ? defaultValuesAtRenderRef.current\r\n                : defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesAtRenderRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            if (isChanged && shouldRender) {\r\n                formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n                updateFormState(Object.assign({}, state));\r\n            }\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        if (fieldsRef.current[name]) {\r\n            const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n            shouldRenderBaseOnError(name, error, skipReRender);\r\n            return isUndefined(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (Array.isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                errors: formStateRef.current.errors,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = useCallback(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (Array.isArray(fields)) {\r\n            !name && (formStateRef.current.errors = {});\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields, readFormStateRef.current.isValid);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = useCallback((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = useCallback((name, value, config = {}) => {\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                fieldArrayDefaultValuesRef.current[name] = value;\r\n                resetFieldArrayFunctionRef.current[name]({\r\n                    [name]: value,\r\n                });\r\n                if ((readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) &&\r\n                    config.shouldDirty) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                        dirtyFields: formStateRef.current.dirtyFields,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name, found = true) => {\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config);\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n        (config || {}).shouldValidate && trigger(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            let name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    if (isCheckBoxInput(target) &&\r\n                        !error &&\r\n                        resolverRef.current) {\r\n                        const parentNodeName = name.substring(0, name.lastIndexOf('.') > name.lastIndexOf('[')\r\n                            ? name.lastIndexOf('.')\r\n                            : name.lastIndexOf('['));\r\n                        const currentError = get(errors, parentNodeName, {});\r\n                        currentError.type &&\r\n                            currentError.message &&\r\n                            (error = currentError);\r\n                        if (parentNodeName &&\r\n                            (currentError ||\r\n                                get(formStateRef.current.errors, parentNodeName))) {\r\n                            name = parentNodeName;\r\n                        }\r\n                    }\r\n                    isValid = isEmptyObject(errors);\r\n                    if (previousFormIsValid !== isValid) {\r\n                        shouldRender = true;\r\n                    }\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            let copy = cloneObject(data, isWeb);\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !copy[value]) {\r\n                    copy = Object.assign(Object.assign({}, copy), { [value]: [] });\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (Array.isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current, isWeb), shouldUnregister));\r\n    }\r\n    const validateResolver = useCallback(async (values = {}) => {\r\n        const { errors } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\r\n    const updateWatchedValue = useCallback((name) => {\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    break;\r\n                }\r\n            }\r\n            renderWatchedInputs(name);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !compact(field.options || []).length) {\r\n                unset(defaultValuesAtRenderRef.current, field.ref.name);\r\n                unset(validFieldsRef.current, field.ref.name);\r\n                unset(fieldsWithValidationRef.current, field.ref.name);\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    errors: formStateRef.current.errors,\r\n                    isDirty: isFormDirty(),\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                });\r\n                readFormStateRef.current.isValid &&\r\n                    resolverRef.current &&\r\n                    validateResolver();\r\n                updateWatchedValue(field.ref.name);\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName)\r\n                ? delete formStateRef.current.errors[inputName]\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n            errors: formStateRef.current.errors,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current, isWeb), shouldUnregister, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            if (fieldArrayNamesRef.current.has(fieldNames)) {\r\n                const fieldArrayValue = get(fieldArrayValuesRef.current, fieldNames, []);\r\n                fieldValues =\r\n                    fieldArrayValue.length !==\r\n                        compact(get(fieldValues, fieldNames, [])).length ||\r\n                        !fieldArrayValue.length\r\n                        ? fieldArrayValuesRef.current\r\n                        : fieldValues;\r\n            }\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue)\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (Array.isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of Array.isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, validateOptions = {}) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!ref.name) {\r\n                return console.warn('📋 Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\r\n            }\r\n            if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\r\n                !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\r\n                    .replace(/\\[/g, '\\\\[')\r\n                    .replace(/\\]/g, '\\\\]')).test(ref.name)) {\r\n                return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? Array.isArray(field.options) &&\r\n                    compact(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...compact((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(validateOptions)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    if (previousFormIsValid !== isEmptyObject(error)) {\r\n                        updateFormState();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n            set(defaultValuesAtRenderRef.current, name, isEmptyDefaultValue\r\n                ? isObject(fieldValue)\r\n                    ? Object.assign({}, fieldValue) : fieldValue\r\n                : defaultValue);\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, rules) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrValidationOptions)) {\r\n                registerFieldRef({ name: refOrValidationOptions }, rules);\r\n            }\r\n            else if (isObject(refOrValidationOptions) &&\r\n                'name' in refOrValidationOptions) {\r\n                registerFieldRef(refOrValidationOptions, rules);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrValidationOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current, isWeb), shouldUnregister, true));\r\n        readFormStateRef.current.isSubmitting &&\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitting = false;\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                errors: formStateRef.current.errors,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = cloneObject(values || defaultValuesRef.current, isWeb);\r\n        values && renderWatchedInputs('');\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        shallowFieldsStateRef.current = shouldUnregister\r\n            ? {}\r\n            : cloneObject(values, isWeb) || {};\r\n        resetRefs(omitResetState);\r\n    };\r\n    useEffect(() => {\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        observerRef.current =\r\n            observerRef.current || !isWeb\r\n                ? observerRef.current\r\n                : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        observerRef.current && observerRef.current.disconnect();\r\n        Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, []);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: useCallback(setValue, [setInternalValue, trigger]),\r\n        getValues: useCallback(getValues, []),\r\n        register: useCallback(register, [defaultValuesRef.current]),\r\n        unregister: useCallback(unregister, []),\r\n    };\r\n    const control = useMemo(() => (Object.assign({ isFormDirty,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        updateFormState,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, validateResolver: resolver ? validateResolver : undefined, fieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        fieldArrayValuesRef }, commonProps)), [\r\n        defaultValuesRef.current,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal,\r\n    ]);\r\n    return Object.assign({ watch,\r\n        control, formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        if (prop === 'isValid' && isOnSubmit) {\r\n                            console.warn('📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\r\n                        }\r\n                    }\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState, handleSubmit, reset: useCallback(reset, []), clearErrors: useCallback(clearErrors, []), setError: useCallback(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => useContext(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (createElement(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return compact(data);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : Array.isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\r\n    if (isObject(value)) {\r\n        const object = {};\r\n        for (const key in value) {\r\n            object[key] = true;\r\n        }\r\n        return [object];\r\n    }\r\n    return [true];\r\n}\r\nvar fillBooleanArray = (value) => (Array.isArray(value) ? value : [value])\r\n    .map(mapValueToBoolean)\r\n    .flat();\n\nconst mapIds = (values = [], keyName) => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        for (const value of values) {\r\n            if (!!value && keyName in value) {\r\n                console.warn(`📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return values.map((value) => (Object.assign({ [keyName]: generateId() }, value)));\r\n};\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\r\n        }\r\n    }\r\n    const focusIndexRef = useRef(-1);\r\n    const { isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef, } = control || methods.control;\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const memoizedDefaultValues = useRef([\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n            : get(shouldUnregister\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name, [])),\r\n    ]);\r\n    const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    set(fieldArrayValuesRef.current, name, fields);\r\n    const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), []);\r\n    const getCurrentFieldsValues = () => get(getValues(), name, getFieldArrayValue()).map((item, index) => (Object.assign(Object.assign({}, getFieldArrayValue()[index]), item)));\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (fieldArrayParentName &&\r\n        !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\r\n    }\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        set(fieldArrayValuesRef.current, name, fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            isMatchFieldArrayName(key, name) &&\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n        }\r\n    };\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {\r\n        const defaultFieldArrayValues = get(defaultValuesRef.current, name, []);\r\n        const updateDirtyFieldsBaseOnDefaultValues = (base, target) => {\r\n            for (const key in base) {\r\n                for (const innerKey in base[key]) {\r\n                    if (innerKey !== keyName &&\r\n                        (!target[key] ||\r\n                            !base[key] ||\r\n                            base[key][innerKey] !== target[key][innerKey])) {\r\n                        set(formStateRef.current.dirtyFields, `${name}[${key}]`, Object.assign(Object.assign({}, get(formStateRef.current.dirtyFields, `${name}[${key}]`, {})), { [innerKey]: true }));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        if (updatedFieldArrayValues) {\r\n            updateDirtyFieldsBaseOnDefaultValues(defaultFieldArrayValues, updatedFieldArrayValues);\r\n            updateDirtyFieldsBaseOnDefaultValues(updatedFieldArrayValues, defaultFieldArrayValues);\r\n        }\r\n    };\r\n    const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n            cleanup(fieldArrayDefaultValuesRef.current);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(formStateRef.current.touched, name)) {\r\n            const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touched, name, output);\r\n            cleanup(formStateRef.current.touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            const output = method(get(formStateRef.current.dirtyFields, name, []), args.argC, args.argD);\r\n            shouldSet && set(formStateRef.current.dirtyFields, name, output);\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        updateFormState({\r\n            errors: formStateRef.current.errors,\r\n            dirtyFields: formStateRef.current.dirtyFields,\r\n            isDirty: isFormDirty(name, updatedFormValues.map((_a = {}) => {\r\n                var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n                return rest;\r\n            })),\r\n            touched: formStateRef.current.touched,\r\n        });\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        const updateFormValues = [\r\n            ...getFieldArrayValue(),\r\n            ...mapIds(Array.isArray(value) ? value : [value], keyName),\r\n        ];\r\n        setFieldAndValidState(updateFormValues);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            updateDirtyFieldsWithDefaultValues(updateFormValues);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            });\r\n        }\r\n        !shouldUnregister &&\r\n            set(shallowFieldsStateRef.current, name, [\r\n                ...(get(shallowFieldsStateRef.current, name) || []),\r\n                value,\r\n            ]);\r\n        focusIndexRef.current = shouldFocus ? fields.length : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldValues = removeArrayAt(fieldValues, index);\r\n        setFieldAndValidState(updatedFieldValues);\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues, insert(fieldValues, index));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                console.warn('📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            defaultValues.pop();\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues);\r\n        }\r\n        updateWatchedValue(name);\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = (data) => {\r\n                resetFields();\r\n                !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n                unset(shallowFieldsStateRef.current, name);\r\n                memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n                setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n            };\r\n        }\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            unset(fieldArrayValuesRef, name);\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name, fields]),\r\n        remove: useCallback(remove, [name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\r\n        }\r\n    }\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const updateValue = useState()[1];\r\n    const idRef = useRef();\r\n    const defaultValueRef = useRef(defaultValue);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (name === '') {\r\n                console.warn('📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\r\n            }\r\n        }\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = () => updateValue({});\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return idRef.current\r\n        ? watchInternal(name, defaultValueRef.current, idRef.current)\r\n        : isUndefined(defaultValue)\r\n            ? isString(name)\r\n                ? get(defaultValuesRef.current, name)\r\n                : Array.isArray(name)\r\n                    ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                    : defaultValuesRef.current\r\n            : defaultValue;\r\n}\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as, render, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n    }\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formStateRef: { current: { isSubmitted, touched }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = useState(getInitialValue());\r\n    const valueRef = useRef(value);\r\n    const ref = useRef({\r\n        focus: () => null,\r\n    });\r\n    const onFocusRef = useRef(onFocus ||\r\n        (() => {\r\n            if (isFunction(ref.current.focus)) {\r\n                ref.current.focus();\r\n            }\r\n            else {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    console.warn(`📋 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`);\r\n                }\r\n            }\r\n        }));\r\n    const shouldValidate = useCallback((isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode)), [\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted,\r\n        touched,\r\n        name,\r\n        mode,\r\n    ]);\r\n    const commonTask = useCallback(([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    }, []);\r\n    const registerField = useCallback((shouldUpdateValue) => {\r\n        if (process.env.NODE_ENV !== 'production' && !name) {\r\n            return console.warn('📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperty({\r\n                name,\r\n                focus: onFocusRef.current,\r\n            }, 'value', {\r\n                set(data) {\r\n                    setInputStateValue(data);\r\n                    valueRef.current = data;\r\n                },\r\n                get() {\r\n                    return valueRef.current;\r\n                },\r\n            }), rules);\r\n            shouldUpdateValue = !get(defaultValuesRef.current, name);\r\n        }\r\n        shouldUpdateValue &&\r\n            isNotFieldArray &&\r\n            setInputStateValue(getInitialValue());\r\n    }, [rules, name, register]);\r\n    useEffect(() => () => unregister(name), [unregister, name]);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (isUndefined(value)) {\r\n                console.warn(`📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\r\n            }\r\n            if ((!as && !render) || (as && render)) {\r\n                console.warn(`📋 ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`);\r\n            }\r\n            if (!isNotFieldArray && isUndefined(defaultValue)) {\r\n                console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        registerField();\r\n    }, [registerField]);\r\n    useEffect(() => {\r\n        !fieldsRef.current[name] && registerField(true);\r\n    });\r\n    const onBlur = useCallback(() => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        shouldValidate(true) && trigger(name);\r\n    }, [\r\n        name,\r\n        touched,\r\n        updateFormState,\r\n        shouldValidate,\r\n        trigger,\r\n        readFormStateRef,\r\n    ]);\r\n    const onChange = useCallback((...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    }), [setValue, name, shouldValidate]);\r\n    const commonProps = {\r\n        onChange,\r\n        onBlur,\r\n        name,\r\n        value,\r\n        ref,\r\n    };\r\n    const props = Object.assign(Object.assign({}, rest), commonProps);\r\n    return as\r\n        ? isValidElement(as)\r\n            ? cloneElement(as, props)\r\n            : createElement(as, props)\r\n        : render\r\n            ? render(commonProps)\r\n            : null;\r\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport Typography from '../Typography';\nimport withStyles from '../styles/withStyles';\nimport FormControlContext, { useFormControl } from '../FormControl/FormControlContext';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: 'flex',\n    height: '0.01em',\n    // Fix IE 11 flexbox alignment. To remove at some point.\n    maxHeight: '2em',\n    alignItems: 'center',\n    whiteSpace: 'nowrap'\n  },\n\n  /* Styles applied to the root element if `variant=\"filled\"`. */\n  filled: {\n    '&$positionStart:not($hiddenLabel)': {\n      marginTop: 16\n    }\n  },\n\n  /* Styles applied to the root element if `position=\"start\"`. */\n  positionStart: {\n    marginRight: 8\n  },\n\n  /* Styles applied to the root element if `position=\"end\"`. */\n  positionEnd: {\n    marginLeft: 8\n  },\n\n  /* Styles applied to the root element if `disablePointerEvents=true`. */\n  disablePointerEvents: {\n    pointerEvents: 'none'\n  },\n\n  /* Styles applied if the adornment is used inside <FormControl hiddenLabel />. */\n  hiddenLabel: {},\n\n  /* Styles applied if the adornment is used inside <FormControl margin=\"dense\" />. */\n  marginDense: {}\n};\nvar InputAdornment = /*#__PURE__*/React.forwardRef(function InputAdornment(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      _props$disablePointer = props.disablePointerEvents,\n      disablePointerEvents = _props$disablePointer === void 0 ? false : _props$disablePointer,\n      _props$disableTypogra = props.disableTypography,\n      disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,\n      position = props.position,\n      variantProp = props.variant,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"component\", \"disablePointerEvents\", \"disableTypography\", \"position\", \"variant\"]);\n\n  var muiFormControl = useFormControl() || {};\n  var variant = variantProp;\n\n  if (variantProp && muiFormControl.variant) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (variantProp === muiFormControl.variant) {\n        console.error('Material-UI: The `InputAdornment` variant infers the variant prop ' + 'you do not have to provide one.');\n      }\n    }\n  }\n\n  if (muiFormControl && !variant) {\n    variant = muiFormControl.variant;\n  }\n\n  return /*#__PURE__*/React.createElement(FormControlContext.Provider, {\n    value: null\n  }, /*#__PURE__*/React.createElement(Component, _extends({\n    className: clsx(classes.root, className, disablePointerEvents && classes.disablePointerEvents, muiFormControl.hiddenLabel && classes.hiddenLabel, variant === 'filled' && classes.filled, {\n      'start': classes.positionStart,\n      'end': classes.positionEnd\n    }[position], muiFormControl.margin === 'dense' && classes.marginDense),\n    ref: ref\n  }, other), typeof children === 'string' && !disableTypography ? /*#__PURE__*/React.createElement(Typography, {\n    color: \"textSecondary\"\n  }, children) : children));\n});\nprocess.env.NODE_ENV !== \"production\" ? InputAdornment.propTypes = {\n  /**\n   * The content of the component, normally an `IconButton` or string.\n   */\n  children: PropTypes.node.isRequired,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes\n  /* @typescript-to-proptypes-ignore */\n  .elementType,\n\n  /**\n   * Disable pointer events on the root.\n   * This allows for the content of the adornment to focus the input on click.\n   */\n  disablePointerEvents: PropTypes.bool,\n\n  /**\n   * If children is a string then disable wrapping in a Typography component.\n   */\n  disableTypography: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  muiFormControl: PropTypes.object,\n\n  /**\n   * The position this adornment should appear relative to the `Input`.\n   */\n  position: PropTypes.oneOf(['start', 'end']),\n\n  /**\n   * The variant to use.\n   * Note: If you are using the `TextField` component or the `FormControl` component\n   * you do not have to set this manually.\n   */\n  variant: PropTypes.oneOf(['standard', 'outlined', 'filled'])\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiInputAdornment'\n})(InputAdornment);","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"sourceRoot":""}